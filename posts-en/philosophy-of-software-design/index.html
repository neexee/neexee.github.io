<!doctype html>

<html lang="en" class="h-100">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <meta name="author" content="Sergey Machulskis" />
  <meta name="generator" content="Hugo 0.86.0-DEV" />
  
  <meta name="description" content="Nice little book. It could be an eye-opening read for a CS student as it has a lot of good advice on medium and low-level code structure. It’s not as useful for a professional programmer, but it could be used for reading for pleasure. It has a couple of concepts with catchy names like “define errors out of existence” and “modules should be deep” which I like because they’re quite practical and rich.">
  <link rel="stylesheet" href="https://neexee.github.io/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://neexee.github.io/css/blockquote.css">
  <link rel="stylesheet" href="https://neexee.github.io/css/images.css">
  
  
  <title>A Philosophy of Software Design | Picky speaker</title>
  <style>
.container {
  max-width: 800px;
}
#nav a {
  font-weight: bold;
  color: inherit;
}
#nav a.nav-link-active {
  background-color: #212529;
  color: #fff;
}
#nav-border {
  border-bottom: 1px solid #212529;
}
#main {
  margin-top: 1em;
  margin-bottom: 4em;
}

#main .taglist {
  margin-top: 1em;
  margin-bottom: 1em;
}

#home-jumbotron {
  background-color: inherit;
}
#footer .container {
  padding: 1em 0;
}
#footer a {
  color: inherit;
  text-decoration: underline;
}
.font-125 {
  font-size: 125%;
}
.tag-btn {
  margin-bottom: 0.3em;
}
pre {
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 16px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  background-color: transparent;
  border-radius: 0;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 4px;
}
img,
iframe,
embed,
video,
audio {
  max-width: 100%;
}
.card-img,
.card-img-top,
.card-img-bottom {
  width: initial;
}
</style>
</head>
  <body class="d-flex flex-column h-100">
    <div id="nav-border" class="container">
  <nav id="nav" class="nav justify-content-center">
  
  
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/"><i data-feather="home"></i> Home</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/resume/"><i data-feather="user-check"></i> Resume</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/posts-en/"><i data-feather="edit"></i> Blog (En)</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/posts-ru/"><i data-feather="edit"></i> Blog (Ru)</a>
  
    
    
      
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/tags/"><i data-feather="tag"></i> Tags</a>
  
  </nav>
</div>

    <div class="container">
      <main id="main">
        

<h1>A Philosophy of Software Design</h1>


  <div class="taglist">
    <i data-feather="tag"></i>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/books">books</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/programming">programming</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/quotes">quotes</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%86">★★★★☆</a>
    
  </div>


<p>Nice little book. It could be an eye-opening read for a CS student as it has a lot of good advice on medium and low-level code structure. It&rsquo;s not as useful for a professional programmer, but it could be used for reading for pleasure. It has a couple of concepts with catchy names like &ldquo;define errors out of existence&rdquo; and &ldquo;modules should be deep&rdquo; which I like because they&rsquo;re quite practical and rich. 90% of the value of this book is on the first half of it.</p>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">There are two general approaches to fighting complexity, both of which will be discussed in this book. The first approach is to eliminate complexity by making code simpler and more obvious. For example, complexity can be reduced by eliminating special cases or using identifiers in a consistent fashion. The second approach to complexity is to encapsulate it, so that programmers can work on a system without being exposed to all of its complexity at once. This approach is called modular design. In modular design, a software system is divided up into modules, such as classes in an object-oriented language. The modules are designed to be relatively independent of each other, so that a programmer can work on one module without having to understand the details of other modules.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">For the purposes of this book, a module is any unit of code that has an interface and an implementation. Each class in an object-oriented programming language is a module. Methods within a class, or functions in a language that isn’t object-oriented, can also be thought of as modules: each of these has an interface and an implementation, and modular design techniques can be applied to them. Higher-level subsystems and services are also modules; their interfaces may take different forms, such as kernel calls or HTTP requests. Much of the discussion about modular design in this book focuses on designing classes, but the techniques and concepts apply to other kinds of modules as well. The best modules are those whose interfaces are much simpler than their implementations. Such modules have two advantages. First, a simple interface minimizes the complexity that a module imposes on the rest of the system. Second, if a module is modified in a way that does not change its interface, then no other module will be affected by the modification. If a module’s interface is much simpler than its implementation, there will be many aspects of the module that can be changed without affecting other modules.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p>The mechanism for file I/O provided by the Unix operating system and its descendants, such as Linux, is a beautiful example of a deep interface. There are only five basic system calls for I/O, with simple signatures: </p>
<ul>
<li>int open(const char* path, int flags, mode_t permissions);</li>
<li> ssize_t read(int fd, void* buffer, size_t count); </li>
<li>ssize_t write(int fd, const void* buffer, size_t count); </li>
<li>off_t lseek(int fd, off_t offset, int referencePosition);</li>
<li>int close(int fd);</li>
</ul>
<p>A modern implementation of the Unix I/O interface requires hundreds of thousands of lines of code, which address complex issues such as:  How are files represented on disk in order to allow efficient access? How are directories stored, and how are hierarchical path names processed to find the files they refer to? How are permissions enforced, so that one user cannot modify or delete another user’s files? How are file accesses implemented? For example, how is functionality divided between interrupt handlers and background code, and how do these two elements communicate safely? What scheduling policies are used when there are concurrent accesses to multiple files? How can recently accessed file data be cached in memory in order to reduce the number of disk accesses? How can a variety of different secondary storage devices, such as disks and flash drives, be incorporated into a single file system? All of these issues, and many more, are handled by the Unix file system implementation; they are invisible to programmers who invoke the system calls. Implementations of the Unix I/O interface have evolved radically over the years, but the five basic kernel calls have not changed.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">Another example of a deep module is the garbage collector in a language such as Go or Java. This module has no interface at all; it works invisibly behind the scenes to reclaim unused memory. Adding garbage collection to a system actually shrinks its overall interface, since it eliminates the interface for freeing objects. The implementation of a garbage collector is quite complex, but that complexity is hidden from programmers using the language.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Shallow Module</strong></p>
<p>A shallow module is one whose interface is complicated relative to the functionality it provides. Shallow modules don’t help much in the battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost of learning and using their interfaces. Small modules tend to be shallow.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">Unfortunately, the value of deep classes is not widely appreciated today. The conventional wisdom in programming is that classes should be small, not deep. Students are often taught that the most important thing in class design is to break up larger classes into smaller ones. The same advice is often given about methods: “Any method longer than N lines should be divided into multiple methods” (N can be as low as 10). This approach results in large numbers of shallow classes and methods, which add to overall system complexity.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p>One of the most visible examples of classitis today is the Java class library. The Java language doesn’t require lots of small classes, but a culture of classitis seems to have taken root in the Java programming community. For example, to open a file in order to read serialized objects from it, you must create three different objects: </p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#111">FileInputStream</span> <span style="color:#111">fileStream</span> <span style="color:#f92672">=</span> <span style="color:#00a8c8">new</span> <span style="color:#111">FileInputStream</span><span style="color:#f92672">(</span><span style="color:#111">fileName</span><span style="color:#f92672">);</span> 
<span style="color:#111">BufferedInputStream</span> <span style="color:#111">bufferedStream</span> <span style="color:#f92672">=</span> <span style="color:#00a8c8">new</span> <span style="color:#111">BufferedInputStream</span><span style="color:#f92672">(</span><span style="color:#111">fileStream</span><span style="color:#f92672">);</span> 
<span style="color:#111">ObjectInputStream</span> <span style="color:#111">objectStream</span> <span style="color:#f92672">=</span> <span style="color:#00a8c8">new</span> <span style="color:#111">ObjectInputStream</span><span style="color:#f92672">(</span><span style="color:#111">bufferedStream</span><span style="color:#f92672">);</span>
</code></pre></div><p> A FileInputStream object provides only rudimentary I/O: it is not capable of performing buffered I/O, nor can it read or write serialized objects. The BufferedInputStream object adds buffering to a FileInputStream, and the ObjectInputStream adds the ability to read and write serialized objects. The first two objects in the code above, fileStream and bufferedStream, are never used once the file has been opened; all future operations use objectStream. It is particularly annoying (and error-prone) that buffering must be requested explicitly by creating a separate BufferedInputStream object; if a developer forgets to create this object, there will be no buffering and I/O will be slow. Perhaps the Java developers would argue that not everyone wants to use buffering for file I/O, so it shouldn’t be built into the base mechanism. They might argue that it’s better to keep buffering separate, so people can choose whether or not to use it. Providing choice is good, but interfaces should be designed to make the common case as simple as possible (see the formula on page 6). Almost every user of file I/O will want buffering, so it should be provided by default. For those few situations where buffering is not desirable, the library can provide a mechanism to disable it. Any mechanism for disabling buffering should be cleanly separated in the interface (for example, by providing a different constructor for FileInputStream, or through a method that disables or replaces the buffering mechanism), so that most developers do not even need to be aware of its existence. </p>
<p>In contrast, the designers of the Unix system calls made the common case simple. For example, they recognized that sequential I/O is most common, so they made that the default behavior. Random access is still relatively easy to do, using the lseek system call, but a developer doing only sequential access need not be aware of that mechanism. If an interface has many features, but most developers only need to be aware of a few of them, the effective complexity of that interface is just the complexity of the commonly used features.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Information Leakage</strong></p>
<p>￼ Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Temporal Decomposition</strong></p>
<p>￼ In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Overexposure</strong></p>
<p>￼ If the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">When decomposing a system into modules, try not to be influenced by the order in which operations will occur at runtime; that will lead you down the path of temporal decomposition, which will result in information leakage and shallow modules. Instead, think about the different pieces of knowledge that are needed to carry out the tasks of your application, and design each module to encapsulate one or a few of those pieces of knowledge. This will produce a clean and simple design with deep modules.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">In my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p>Knowing this, some of the teams created one method in the text class to support each of these specific features:</p>
<div class="highlight"><pre style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#00a8c8">void</span> <span style="color:#75af00">backspace</span><span style="color:#f92672">(</span><span style="color:#111">Cursor</span> <span style="color:#111">cursor</span><span style="color:#f92672">);</span>
 <span style="color:#00a8c8">void</span> <span style="color:#75af00">delete</span><span style="color:#f92672">(</span><span style="color:#111">Cursor</span> <span style="color:#111">cursor</span><span style="color:#f92672">);</span> 
</code></pre></div><p>Each of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:  <code>void deleteSelection(Selection selection);</code></p>
<p>This approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well.</p>
<p>A better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text: void insert(Position position, String newText); void delete(Position start, Position end);</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">What is the simplest interface that will cover all my current needs? If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things. In how many situations will this method be used? If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method. Is this API easy to use for my current needs? This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Pass-Through Method</strong></p>
<p>￼ A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?”.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Special-General Mixture</strong></p>
<p>￼ This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.</p>
<p>Each method should do one thing and do it completely.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary"><p><strong>Red Flag: Conjoined Methods</strong></p>
<p>￼ It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.</p>
</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">Classes with lots of exceptions have complex interfaces, and they are shallower than classes with fewer exceptions.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">The best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">The Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the delete succeeds, and the file will eventually be deleted. Second, deleting a file that’s in use does not create exceptions for the processes using the file. One possible approach to this problem would have been to delete the file immediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach would create new errors for those processes to handle. Instead, Unix allows them to keep accessing the file normally; delaying the file deletion defines errors out of existence.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">When I argue for defining errors out of existence, people sometimes counter that throwing errors will catch bugs; if errors are defined out of existence, won’t that result in buggier software? Perhaps this is why the Java developers decided that substring should throw exceptions. The error-ful approach may catch some bugs, but it also increases complexity, which results in other bugs. In the error-ful approach, developers must write additional code to avoid or ignore the errors, and this increases the likelihood of bugs; or, they may forget to write the additional code, in which case unexpected errors may be thrown at runtime. In contrast, defining errors out of existence simplifies APIs and it reduces the amount of code that must be written. Overall, the best way to reduce bugs is to make software simpler.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">This example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, it’s useful to define an exception that aborts the current request, cleans up the system’s state, and continues with the next request. The exception is caught in a single place near the top of the system’s request-handling loop. This exception can be thrown at any point in the processing of a request to abort the request; different subclasses of the exception can be defined for different conditions. Exceptions of this type should be clearly distinguished from exceptions that are fatal to the entire system.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">RAMCloud does not have separate recovery mechanisms for each different kind of error. Instead, RAMCloud “promotes” many smaller errors into larger ones. RAMCloud could, in principle, handle a corrupted object by restoring that one object from a backup copy. However, it doesn’t do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloud uses this approach because crash recovery is quite complex and this approach minimized the number of different recovery mechanisms that had to be created. Creating a recovery mechanism for crashed servers was unavoidable, so RAMCloud uses the same mechanism for other kinds of recovery as well. This reduced the amount of code that had to be written, and it also meant that server crash recovery gets invoked more often. As a result, bugs in recovery are more likely to be discovered and fixed. One disadvantage of promoting a corrupted object into a server crash is that it increases the cost of recovery considerably. This is not a problem in RAMCloud, since object corruption is quite rare. However, error promotion may not make sense for errors that happen frequently. As one example, it would not be practical to crash a server anytime one of its network packets is lost. One way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">With exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when something is important, it must be exposed.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">I have noticed that the design-it-twice principle is sometimes hard for really smart people to embrace. When they are growing up, smart people discover that their first quick idea about any problem is sufficient for a good grade; there is no need to consider a second or third possibility. This makes it easy to develop bad work habits. However, as these people get older, they get promoted into environments with harder and harder problems. Eventually, everyone reaches a point where your first ideas are no longer good enough; if you want to get really great results, you have to consider a second possibility, or perhaps a third, no matter how smart you are.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">The design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approaches will teach you about the factors that make designs better or worse. Over time, this will make it easier for you to rule out bad designs and hone in on really great ones.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">Comments are fundamental to abstractions. Recall from Chapter 4 that the goal of abstractions is to hide complexity: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">If you want code that presents good abstractions, you must document those abstractions with comments.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>


  
  

  

  
    
  
  
  
  

  
  

  

  
  
  
  

  
  

  

  
    
  
  
  
  

  
  

  

  
    
  
  
  
  





  


<blockquote class="wp-block-quote">
  <div class="text-secondary">If interface comments must also describe the implementation, then the class or method is shallow.</div>
  
    <footer class=blockquote-footer>
      <strong>John Ousterhout</strong>
      
        
          <cite>
            <a href="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design" title="https://www.goodreads.com/book/show/39996759-a-philosophy-of-software-design">A Philosophy of Software Design</a> 
          </cite>
        
      
    </footer>
  
</blockquote>



      </main>
    </div>
    
    <script src="https://neexee.github.io/js/feather.min.js"></script>
<script>
  feather.replace()
</script>


    



    
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-143695654-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  </body>
</html>