<!doctype html>

<html lang="en" class="h-100">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="generator" content="Hugo 0.59.0-DEV" />
  <link rel="stylesheet" href="https://neexee.github.io/css/bootstrap.min.css">
  <link rel="stylesheet" href="https://neexee.github.io/css/blockquote.css">
  <link rel="stylesheet" href="https://neexee.github.io/css/images.css">
  
  
  <title>Release it! Second edition | Picky speaker</title>
  <style>
.container {
  max-width: 800px;
}
#nav a {
  font-weight: bold;
  color: inherit;
}
#nav a.nav-link-active {
  background-color: #212529;
  color: #fff;
}
#nav-border {
  border-bottom: 1px solid #212529;
}
#main {
  margin-top: 1em;
  margin-bottom: 4em;
}

#main .taglist {
  margin-top: 1em;
  margin-bottom: 1em;
}

#home-jumbotron {
  background-color: inherit;
}
#footer .container {
  padding: 1em 0;
}
#footer a {
  color: inherit;
  text-decoration: underline;
}
.font-125 {
  font-size: 125%;
}
.tag-btn {
  margin-bottom: 0.3em;
}
pre {
  background-color: #f5f5f5;
  border: 1px solid #ccc;
  border-radius: 4px;
  padding: 16px;
}
pre code {
  padding: 0;
  font-size: inherit;
  color: inherit; 
  background-color: transparent;
  border-radius: 0;
}
code {
  padding: 2px 4px;
  font-size: 90%;
  color: #c7254e;
  background-color: #f9f2f4;
  border-radius: 4px;
}
img,
iframe,
embed,
video,
audio {
  max-width: 100%;
}
</style>
</head>
  <body class="d-flex flex-column h-100">
    <div id="nav-border" class="container">
  <nav id="nav" class="nav justify-content-center">
  
  
  
    
    
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/"><i data-feather="home"></i> Home</a>
  
    
    
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/posts-en/"><i data-feather="edit"></i> Blog (En)</a>
  
    
    
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/posts-ru/"><i data-feather="edit"></i> Blog (Ru)</a>
  
    
    
      
      
      
      
        
      
    
    
    <a class="nav-link " href="/tags/"><i data-feather="tag"></i> Tags</a>
  
  </nav>
</div>
    <div class="container">
      <main id="main">
        

<h1>Release it! Second edition</h1>


  <div class="taglist">
    <i data-feather="tag"></i>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/books">books</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/non-programming">non-programming</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/quotes">quotes</a>
    
      
      <a class="btn btn-sm btn-outline-dark tag-btn" href="https://neexee.github.io/tags/%E2%98%85%E2%98%85%E2%98%85%E2%98%85%E2%98%85">★★★★★</a>
    
  </div>


<p><strong>Faults and cracks</strong>:</p>

<ul>
<li>Fault. A condition that creates an incorrect internal state in your software. A fault may be due to a latent bug that gets triggered, or it may be due to an unchecked condition at a boundary or external interface.</li>
<li>Error. Visibly incorrect behavior. When your trading system suddenly buys ten billion dollars of Pokemon futures, that is an error.</li>
<li>Failure. An unresponsive system. When a system doesn’t respond, we say it has failed. Failure is in the eye of the beholder. A computer may have the power on but not respond to any requests.</li>
<li>Triggering a fault opens the crack. Faults become errors, and errors provoke failures. That’s how the cracks propagate.</li>
<li>Tight coupling accelerates cracks.</li>
</ul>

<p><strong>Stability antipatterns</strong>:</p>

<ul>
<li>Integration points

<ul>
<li>Every integration point will eventually fail in some way, and you need to be prepared for that failure.</li>
<li>Prepare for the many forms of failure.</li>
<li>Know when to open up abstractions. Mechanism to peel off layers of abstractions. Wireshark</li>
<li>Failures propagate quickly. Failure in a remote system quickly becomes your problem.</li>
<li>Apply patterns to avert integration point problems. Circuit breaker, timeouts, decoupling middleware and handshaking</li>
</ul></li>
<li>Chain reactions

<ul>
<li>Recognize that one server down jeopardizes the rest. No Single point of failure is not enough. It&rsquo;s bad when remaining instances cannot handle the load.</li>
<li>Hunt for resource leaks.</li>
<li>Hunt for obscure timing bugs.</li>
<li>Use Autoscaling.</li>
<li>Defend with Bulkheads.</li>
</ul></li>
<li>Blocking threads

<ul>
<li>Recall that the Blocked Threads antipattern is the proximate cause of most failures.</li>
<li>Scrutinize resource pools. Like Cascading Failures, the Blocked Threads antipattern usually happens around resource pools, particularly database connection pools. A deadlock in the database can cause connections to be lost forever, and so can incorrect exception handling.</li>
<li>Use proven primitives</li>
<li>Defend with timeouts. No-timeout version of a function is &ldquo;CheckoutAndMaybeKillMySystem&rdquo;.</li>
<li>Beware the code you cannot see</li>
</ul></li>
<li>Self-denial attacks.

<ul>
<li>Keep the lines of communication open.</li>
<li>Protect shared resources. (No exponential backend processing because of bug on frontend)</li>
<li>Expect rapid redistribution of any cool or valuable offer.</li>
</ul></li>
<li>Scaling effects

<ul>
<li>Examine production versus QA environments to spot Scaling Effects.</li>
<li>Watch out for point-to-point communication.</li>
<li>Watch out for shared resources.</li>
</ul></li>
<li>Unbalanced capacities

<ul>
<li>Examine server and thread counts.</li>
<li>Observe near Scaling Effects and users.</li>
<li>Virtualize QA and scale it up.</li>
<li>Stress both sides of the interface.</li>
</ul></li>
<li>Dogpile (american football)

<ul>
<li>Dogpiles force you to spend too much to handle peak demand.</li>
<li>Use random clock slew to diffuse the demand.</li>
<li>Use increasing backoff times to avoid pulsing.</li>
</ul></li>
<li>Force multiplier.

<ul>
<li>Ask for help before causing havoc. Infrastructure management tools can make very large impacts very quickly. Build limiters and safeguards into them so they won’t destroy your whole system at once.</li>
<li>Beware of lag time and momentum.</li>
<li>Beware of illusions and superstitions. Control systems sense the environment, but they can be fooled.</li>
</ul></li>
<li>Slow responses

<ul>
<li>Slow Responses trigger Cascading Failures.</li>
<li>For websites, Slow Responses cause more traffic.</li>
<li>Consider Fail Fast. If slow responses are worse than no response, the worst must surely be a slow failure response. Fail fast.</li>
<li>Hunt for memory leaks or resource contention.</li>
</ul></li>
<li>Unbounded result sets

<ul>
<li>Use realistic data volumes.</li>
<li>Paginate at the front end. Do not put too much trust in your database, always LIMIT your queries. Same for frontend and huge json in response.</li>
<li>Don’t rely on the data producers.</li>
<li>Put limits into other application-level protocols.</li>
</ul></li>
</ul>

<p><strong>Health checks</strong> should be more than just “yup, it’s running.” It should report at least the following:</p>

<ul>
<li>The host IP address or addresses</li>
<li>The version number of the runtime or interpreter (Ruby, Python, JVM, .Net, Go, and so on)</li>
<li>The application version or commit ID</li>
<li>Whether the instance is accepting work</li>
<li>The status of connection pools, caches, and circuit breakers</li>
</ul>

<p><strong>Useful metrics</strong>:</p>

<ul>
<li>Traffic indicators

<ul>
<li>Page requests, page requests total, transaction counts, concurrent sessions</li>
</ul></li>
<li>Business transaction, for each type

<ul>
<li>Number processed, number aborted, dollar value, transaction aging,conversion rate, completion rate</li>
</ul></li>
<li>Users

<ul>
<li>Demographics or classification, technographics, percentage of users who are registered, number of users, usage patterns, errors encountered, successful logins, unsuccessful logins</li>
</ul></li>
<li>Resource pool health

<ul>
<li>Enabled state, total resources (as applied to connection pools, worker thread pools, and any other resource pools), resources checked out, high-water mark, number of resources created, number of resources destroyed,number of times checked out, number of threads blocked waiting for a resource, number of times a thread has blocked waiting</li>
</ul></li>
<li>Database connection health

<ul>
<li>Number of SQLExceptions thrown, number of queries, average response time to queries</li>
</ul></li>
<li>Data consumption

<ul>
<li>Number of entities or rows present, footprint in memory and on disk</li>
</ul></li>
<li>Integration point health

<ul>
<li>State of circuit breaker, number of timeouts, number of requests, average response time, number of good responses, number of network errors, number of protocol errors, number of application errors, actual IP address of the remote endpoint, current number of concurrent requests, concurrent request high-water mark</li>
</ul></li>
<li>Cache health

<ul>
<li>Items in cache, memory used by cache, cache hit rate, items flushed by garbage collector, configured upper limit, time spent creating items</li>
</ul></li>
</ul>

<p>All of the counters have an implied time component. You should read them as if they all end with “in the last n minutes” or “since the last reset.”</p>

<p>A few pointers about <strong>configuration services</strong>:</p>

<ul>
<li>Make sure your instances can start without the configuration service.</li>
<li>Make sure your instances don’t stop working when configuration is unreachable.</li>
<li>Make sure that a partitioned configuration node doesn’t have the ability to shut down the world.</li>
<li>Replicate across geographic regions.</li>
</ul>

<p><strong>Continuous Deployment</strong></p>

<p>Between the time a developer commits code to the repository and the time it runs in production, code is a pure liability. Undeployed code is unfinished inventory. It has unknown bugs. It may break scaling or cause production downtime. It might be a great implementation of a feature nobody wants. Until you push it to production, you can’t be sure. The idea of continuous deployment is to reduce that delay as much as possible to minimize the liability of undeployed code. See vicious cycle from Site Reliability Workbook. (If it hurts do it more often).</p>

<p><strong>Schemaless Databases</strong></p>

<ul>
<li>First approach. Translation pipeline</li>
</ul>

<p><img src="translation-pipeline.png" alt="" /></p>

<ul>
<li>The second approach is to write a migration routine that you run across your entire database during deployment. That will work well in the early stages, while your data is still small.</li>
<li>The third approach: “trickle, then batch”. In this strategy, we don’t apply one massive migration to all documents. Rather, we add some conditional code in the new version that migrates documents as they are touched.</li>
</ul>

<p><strong>API Changes</strong></p>

<p>What we call an “API” is really a layered stack of agreements between pieces of software. Some of the agreements are so fundamental (we use TCP/IP most of the time, for example).</p>

<p>The consumer and provider must share a number of additional agreements in order to communicate. We can think of these as agreements in the following situations:</p>

<ul>
<li>Connection handshaking and duration</li>
<li>Request framing</li>
<li>Content encoding</li>
<li>Message syntax</li>
<li>Message semantics</li>
<li>Authorization and authentication</li>
</ul>

<p>List of changes that would break agreements:</p>

<ul>
<li>Rejecting a network protocol that previously worked</li>
<li>Rejecting request framing or content encoding that previously worked</li>
<li>Rejecting request syntax that previously worked</li>
<li>Rejecting request routing (whether URL or queue) that previously worked</li>
<li>Adding required fields to the request</li>
<li>Forbidding optional information in the request that was allowed before</li>
<li>Removing information from the response that was previously guaranteed</li>
<li>Requiring an increased level of authorization</li>
</ul>

<p>The following changes are always safe:</p>

<ul>
<li>Require a subset of the previously required parameters</li>
<li>Accept a superset of the previously accepted parameters</li>
<li>Return a superset of the previously returned values</li>
<li>Enforce a subset of the previously required constraints on the parameters</li>
</ul>

<p>A tough problem arises that we need to address when applying the Robustness Principle, though. There may be a gap between what we say our service accepts and what it really accepts. For instance, suppose a service takes JSON payloads with a “url” field. You discover that the input is not validated as a URL, but just received as a string and stored in the database as a string. You want to add some validation to check that the value is a legitimate URL, maybe with a regular expression. Bad news: the service now rejects requests that it previously accepted. That is a breaking change.</p>

<p>But wait a minute! The documentation said to pass in a URL. Anything else is bad input and the behavior is undefined. It could do absolutely anything. The classic definition of “undefined behavior” for a function means it may decide to format your hard drive. It doesn’t matter. As soon as the service went live, its implementation becomes the de facto specification.</p>

<p>It’s common to find gaps like these between the documented protocol and what the software actually expects. I like to use generative testing techniques to find these gaps before releasing the software. But once the protocol is live, what should you do? Can you tighten up the implementation to match the documentation? No. The Robustness Principle says we have no choice but to keep accepting the input.</p>

<p><strong>HTTP API versioning</strong></p>

<p>HTTP gives us several options to deal with breaking changes. None are beautiful.</p>

<ul>
<li>Add a version discriminator to the URL, either as a prefix or a query parameter. This is the most common approach in practice. Advantages: It’s easy to route to the correct behavior. URLs can be shared, stored, and emailed without requiring any special handling. You can also query your logs to see how many consumers are using each version over time. For the consumer, a quick glance will confirm which version they are using. Disadvantage: Different representations of the same entity seem like different resources, which is a big no-no in the REST world.</li>
<li>Use the “Accept” header on GET requests to indicate the desired version. Use the “Content-Type” header on PUT and POST to indicate the version being sent. For example, we can define a media type “application/vnd.lendzit.loan-request.v1” and a new media type “application/vnd.lendzit.loan-request.v2” for our versions. If a client fails to specify a desired version, it gets the default (the first nondeprecated version.) Advantage: Clients can upgrade without changing routes because any URLs stored in databases will continue to work. Disadvantages: The URL alone is no longer enough. Generic media types like “application/json” and “text/xml” are no help at all. The client has to know that the special media types exist at all, and what the range of allowed media types are. Some frameworks support routing based on media type with varying degrees of difficulty.</li>
<li>Use an application-specific custom header to indicate the desired version. We can define a header like “api-version.” Advantages: Complete flexibility, and it’s orthogonal to the media type and URL. Disadvantages: You’ll need to write routing helpers for your specific framework. This header is another piece of secret knowledge that must be shared with your consumers.</li>
<li>For PUT and POST only, add a field in the request body to indicate the intended version. Advantages: No routing needed. Easy to implement. Disadvantage: Doesn’t cover all the cases we need.</li>
</ul>

<p>In the end, I usually opt for putting something in the URL. A couple of benefits outweigh the drawbacks for me. First, the URL by itself is enough. A client doesn’t need any knowledge beyond that. Second, intermediaries like caches, proxies, and load balancers don’t need any special (read: error-prone) configuration. Matching on URL patterns is easy and well understood by everyone in operations. Specifying custom headers or having the devices parse media types to direct traffic one way or another is much more likely to break. This is particularly important to me when the next framework change, where I’d really like to have the new version running on a separate cluster.</p>

<p><strong>Think globally and act locally</strong></p>

<p>Like many places where our software intersects with the external environment, versioning is inherently messy. It will always remain a complex topic. I recommend a utilitarian philosophy. The net suffering in your organization is minimized if everyone thinks globally and acts locally. The alternative is an entire organization slowly grinding to a halt as every individual release gets tied down waiting for synchronized upgrades of its clients.</p>

<p><strong>Sessions vs users</strong></p>

<p><img src="sessions-vs-users.png" alt="" /></p>

<p>When you look at all of the active sessions, some of them are destined to expire without another request. The number of active sessions is one of the most important measurements about a web system, but don’t confuse it with counting users.</p>

<p><strong>The Danger of Thrashing</strong></p>

<p>Thrashing happens when your organization changes direction without taking the time to receive, process, and incorporate feedback. You may recognize it as constantly shifting development priorities or an unending series of crises.</p>

<p>We constantly encourage people to shorten cycle time and reduce the time between sensing and acting. But be careful not to shorten development cycle time so much that it’s faster than how quickly you get feedback from the environment.</p>

<p>In aviation, there’s an effect officially called “pilot-induced oscillation” and unofficially called “porpoising.” Suppose a pilot needs to raise the aircraft’s pitch. He pulls back on the stick, but there’s a long delay between when he moves the stick and when the plane moves, so he keeps pulling the stick back. Once the plane does change attitude, the nose goes up too far. So the pilot pushes the stick forward, but the same delay provokes him to overcontrol in the other direction. It’s called “porpoising” because the plane starts to leap up and dive down like a dolphin at SeaWorld. In our industry, “porpoising” is called thrashing. It happens when the feedback from the environment is slower than the rate of control changes. One effort will be partly completed when a whole new direction appears. It creates team confusion, unfinished work, and lost productivity.</p>

<p>To avoid thrashing, try to create a steady cadence of delivery and feedback. If one runs faster than the other, you could slow it down, but I wouldn’t recommend it! Instead, use the extra time to find ways to speed up the other process. For example, if development moves faster than feedback, don’t use the spare cycles to build dev tools that speed up deployment. Instead, build an experimentation platform to help speed up observation and decisions.</p>

<p><strong>Costly releases</strong></p>

<p>Releases should about as big an event as getting a haircut (or compiling a new kernel, for you gray-ponytailed UNIX hackers who don’t require haircuts).</p>

<p>The literature on agile methods, lean development, continuous delivery, and incremental funding all make a powerful case for frequent releases in terms of user delight and business value. With respect to production operations, however, there’s an added benefit of frequent releases. It forces you to get really good at doing releases and deployments.</p>

<p>A closed feedback loop is essential to improvement. The faster that feedback loop operates, the more accurate those improvements will be. This demands frequent releases. Frequent releases with incremental functionality also allow your company to outpace its competitors and set the agenda in the marketplace.</p>

<p>As commonly practiced, releases cost too much and introduce too much risk. The kind of manual effort and coordination I described previously is barely sustainable for three or four releases a year. It could never work for twenty a year. One solution—the easy but harmful one—is to slow down the release calendar. Like going to the dentist less frequently because it hurts, this response to the problem can only exacerbate the issue. The right response is to reduce the effort needed, remove people from the process, and make the</p>

<p>whole thing more automated and standardized.</p>

<p>In <a href="https://www.amazon.com/Continuous-Delivery-Deployment-Automation-Addison-Wesley/dp/0321601912">Continuous Delivery</a> Jez Humble and Dave Farley describe a number of ways to deliver software continuously and at low risk.</p>

<p><strong>Service Extintion</strong></p>

<p>Paradoxically, the key to making evolutionary architecture work is failure. You have to try different approaches to similar problems and kill the ones that are less successful.</p>

<p>Suppose you have two ideas about promotions that will encourage users to register. You’re trying to decide between cross-site tracking bugs to zero in on highly interested users versus a blanket offer to everyone. The big service will accumulate complexity faster than the sum of two smaller services. That’s because it must also make decisions about routing and precedence (at a minimum.) Larger codebases are more likely to catch a case of “frameworkitis” and become overgeneralized. There’s a vicious cycle that comes into play: more code means it’s harder to change, so every piece of code needs to be more generalized, but that leads to more code. Also, a shared database means every change has a higher potential to disrupt.</p>

<p>There’s little isolation of failure domains here.</p>

<p><img src="failure-domain-isolation.png" alt="" /></p>

<p>Instead of building a single “promotions service” as before, you could build two services that can each chime in when a new user hits your front end. In the next figure, each service makes a decision based on whatever user information is available.</p>

<p><img src="independent-services.png" alt="" /></p>

<p>Each promotion service handles just one dimension. The user offers still need a database, but maybe the page-based offers just require a table of page types embedded in the code. After all, if you can deploy code changes in a matter of minutes, do you really need to invest in content management? Just call your source code repo the content management repository.</p>

<p>It’s important to note that this doesn’t eliminate complexity. Some irreducible —even essential—complexity remains. It does portion the complexity into different codebases, though. Each one should be easier to maintain and prune, just as it’s easier to prune a bonsai juniper than a hundred-foot oak. Here, instead of making a single call, the consumer has to decide which of the services to call. It may need to issue calls in parallel and decide which response to use (if any arrive at all). One can further subdivide the complexity by adding an application-aware router between the caller and the offer services.</p>

<p>One service will probably outperform the other. (Though you need to define “outperform.” Is it based just on the conversion rate? Or is it based on customer acquisition cost versus lifetime profitability estimates?) What should you do with the laggard? There are only five choices you can make:</p>

<ul>
<li>Keep running both services, with all their attendant development and operational expenses.</li>
<li>Take away funding from the successful one and use that money to make the unsuccessful one better.</li>
<li>Retool the unsuccessful one to work in a different area where it isn’t head-to-head competing with the better one. Perhaps target a different user segment or a different part of the customer life cycle.</li>
<li>Delete the unsuccessful one. Aim the developers at someplace where they can do something more valuable.</li>
<li>Give up, shut down the whole company, and open a hot dog and doughnut shop in Fiji.</li>
</ul>

<p><strong>Team-Scale Autonomy</strong></p>

<p>You’re probably familiar with the concept of the two-pizza team. This is Amazon founder and CEO Jeff Bezos’s rule that every team should be sized no bigger than you can feed with two large pizzas. It’s an important but misunderstood concept. It’s not just about having fewer people on a team. That does have its own benefit for communication.</p>

<p>A self-sufficient two-pizza team also means each team member has to cover more than one discipline. You can’t have a two-pizza team if you need a dedicated DBA, a front-end developer, an infrastructure guru, a back-end developer, a machine-learning expert, a product manager, a GUI designer, and so on.</p>

<p>The two-pizza team is about reducing external dependencies. Every dependency is like one of the Lilliputian’s ropes tying Gulliver to the beach. Each dependency thread may be simple to deal with on its own, but a thousand of them will keep you from breaking free.</p>

<p><strong>System architecture</strong></p>

<p>In &ldquo;The Evolution of Useful Things&rdquo;, Henry Petroski argues that the old dictum “Form follows function” is false. In its place, he offers the rule of design evolution, “Form follows failure.” That is, changes in the design of such commonplace things as forks and paper clips are motivated more by the things early designs do poorly than those things they do well. Not even the</p>

<p>humble paper clip sprang into existence in its present form. Each new attempt differs from its predecessor mainly in its attempts to correct flaws.</p>

<p><strong>Targeting chaos</strong></p>

<p>Randomness works well at the beginning because the search space for faults is densely populated. As you progress, the search space becomes more sparse, but not uniform. Some services, some network segments, and some combinations of state and request will still have latent killer bugs. But imagine trying to exhaustively search a 2n dimensional space, where n is the number of calls from service to service. In the worst case, if you have x services, there could be 2^(2x) possible faults to inject!</p>

<p>At some point, we can’t rely just on randomness. We need a way to devise more targeted injections. Humans can do that by thinking about how a successful request works. A top-level request generates a whole tree of calls that support it. Kick out one of the supports, and the request may succeed or it may fail. Either way we learn something. This is why it’s important to study all the times when faults happen without failures. The system did something to keep that fault from becoming a failure. We should learn from those happy outcomes, just as we learn from the negative ones.</p>

<p><strong>Quotes, tips and tricks</strong>:</p>

<ul>
<li>SQL statement close can throw an exception. JDBC allows that.</li>
<li>Services on the web are butterflies and spiders.</li>
<li>Connections are abstractions, they exist only in host&rsquo;s memory. Firewall can drop it. TCP stack is gonna spend 30 minutes resending packets until it realizes connection was dropped by a router.</li>
<li>Liskov substitution principle says that if method is free of side effects then it should be free of them in derived classes</li>
<li>Bad: net.Listen(&ldquo;TCP&rdquo;, &ldquo;:8080&rdquo;). Good: net.Listen(&rdquo;<a href="http://spock.example.com:8080/">spock.example.com:8080</a>&rdquo;)</li>
<li><a href="https://en.wikipedia.org/wiki/Little%27s_law">Little&rsquo;s law</a></li>
<li>It&rsquo;s very difficult to debug in the container. That&rsquo;s why you gonna need a lot of telemetry.</li>
<li>Circuit breaker. <em>Fail fast or &ldquo;whoosh and no more house&rdquo;</em>. Fault density. The idea is to use a leaky bucket, it increases counter on fails and decreases it periodically in background thread</li>
<li>Test harness. The test harness can be designed like an application server; it can have pluggable behavior for the tests that are related to the real application. A single framework for the test harness can be subclassed to implement any application-level protocol, or any perversion of the application-level protocol, necessary. Broadly speaking, a test harness leads toward “chaos engineering”.</li>
<li>Every performance problem starts with a queue backing up somewhere.</li>
<li>Apply Back Pressure within a system boundary. Across boundaries, look at load shedding instead. This is especially true when the Internet at large is your user base.</li>
<li>Queues must be finite for response times to be finite. You only have a few options when a queue is full. All of them are unpleasant: drop data, refuse work, or block. Consumers must be careful not to block forever.</li>
<li>Listen queue length. If you want to apply a heuristic, take your maximum wait time divided by mean processing time and add one. Multiply that by the number of request handling threads you have and bump it up by 50 percent. That’s a reasonable starting point.</li>
<li>ZooKeeper is a &ldquo;CP&rdquo; system. (CAP-theorem)</li>
<li>Systems can mature if, and only if, they have some degree of transparency</li>
<li>&ldquo;Data channel lifetime limit reached. Reset required&rdquo;. They did failover of the database, but it was a debug message about encryption key soon will be vulnerable for discovery</li>
<li>Logs should contain some ids. User Id, transaction Id, whatever. Something grepable.</li>
<li>&hellip; to be available 24 by 7 by 365. That phrase has always bothered me. As an engineer, I expect it to either be “24 by 365” or be “24 by 7 by 52.”</li>
<li><a href="https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet">XSS (Cross Site Scripting) Prevention Cheat Sheet</a></li>
<li><a href="https://www.owasp.org/index.php/HTTP_Strict_Transport_Security_Cheat_Sheet">HSTS</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</a></li>
<li>Containers give you small attack surface. When you include more and more parts of the operating system into it, attack surface grows.</li>
<li>If a caller is not authorized to see the contents of a resource, it should be as if the resource doesn’t even exist.</li>
<li>URLs are pointers. You can pass it around or you can dereference it.</li>
<li><a href="https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf">On the criteria to be used in decomposing systems</a></li>
</ul>



      </main>
    </div>
    
    <script src="https://neexee.github.io/js/feather.min.js"></script>
<script>
  feather.replace()
</script>


    
  
  <script>
  window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
  ga('create', 'UA-143695654-1', 'auto');
  ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  

  </body>
</html>